CREATE EXTENSION IF NOT EXISTS http;
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pg_net;

ALTER DATABASE postgres SET timezone TO 'Africa/Cairo';

CREATE TABLE IF NOT EXISTS public.user_settings (
 id int8 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 device_id text NOT NULL UNIQUE, 
 user_supabase_url text,
 user_supabase_key text,
 amazon_access_key text,
 amazon_secret_key text,
 amazon_partner_tag text,
 tg_bot_token text,
 tg_chat_id text,
 tg_admin_id text,
 fb_page_id text,
 fb_access_token text,
 ai_api_key text,
 post_template text, 
 post_footer text,
 browserless_key text,
 tinyurl_key text,
 short_link_alias text,
 updated_at timestamptz DEFAULT now() 
);

CREATE TABLE IF NOT EXISTS public.products (
 asin text PRIMARY KEY,
 user_id text,
 title text,
 image text,
 price float8,
 old_price float8,
 discount int4,
 extra_payment_discount int4 DEFAULT 0,
 template_id int4 DEFAULT 0,
 affiliate_link text,
 message_id int8, 
 fb_post_id text,  
 is_available boolean DEFAULT true,
 disable_notification boolean DEFAULT false, 
 published_at text,
 scheduled_at timestamptz,
 custom_template text,
 footer_text text, last_update timestamptz DEFAULT now()
);

INSERT INTO storage.buckets (id, name, public)
VALUES ('banners', 'banners', true)
ON CONFLICT (id) DO NOTHING;

DO $$ BEGIN
 IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Public Access') THEN
 CREATE POLICY "Public Access" ON storage.objects FOR SELECT USING (bucket_id = 'banners');
 END IF;
 IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Service Role Full Access') THEN
 CREATE POLICY "Service Role Full Access" ON storage.objects FOR ALL TO service_role USING (bucket_id = 'banners') WITH CHECK (bucket_id = 'banners');
 END IF;
END $$;


CREATE OR REPLACE FUNCTION handle_scheduled_publishing()
RETURNS void AS $$
DECLARE
item RECORD;
set RECORD;
final_text text;
final_price int;
old_price_val int;
time_part text;
tg_result jsonb;
fb_result jsonb;
fb_clean_text text;
real_tg_token text;
real_fb_token text;
v_tg_msg_id int8;
v_fb_post_id text;
final_image_url text;
sign_result jsonb;
new_price float8;
new_image text;
v_clean_title text;
v_processed_footer text := '';
price_display text;
savings_line text := '';
BEGIN
PERFORM set_config('http.timeout_msec', '60000', true);

FOR item IN
SELECT * FROM products
WHERE published_at IS NULL
AND scheduled_at <= (NOW() AT TIME ZONE 'Africa/Cairo')
ORDER BY scheduled_at ASC 
LIMIT 1 
FOR UPDATE SKIP LOCKED
LOOP
v_tg_msg_id := NULL;
v_fb_post_id := NULL;
v_processed_footer := '';

SELECT * INTO set FROM user_settings WHERE device_id = item.user_id LIMIT 1;
IF set IS NULL THEN CONTINUE; END IF;


BEGIN
            SELECT content::jsonb INTO sign_result FROM http_post(
                (rtrim(set.user_supabase_url, '/') || '/functions/v1/sign-request')::text,
                jsonb_build_object(
                    'asin', item.asin,
                    'amazonKeys', jsonb_build_object(
                        'accessKey', set.amazon_access_key,
                        'secretKey', set.amazon_secret_key,
                        'partnerTag', set.amazon_partner_tag
                    )
                )::text,
                'application/json');

            new_price := (sign_result->'ItemsResult'->'Items'->0->'OffersV2'->'Listings'->0->'Price'->'Money'->>'Amount')::float8;
            new_image := COALESCE(
                sign_result->'ItemsResult'->'Items'->0->'Images'->'Primary'->'Large'->>'URL',
                sign_result->'ItemsResult'->'Items'->0->'Images'->'Primary'->'HighRes'->>'URL'
            );

            IF new_price IS NOT NULL AND new_price > 0 THEN
                UPDATE products SET 
                    old_price = CASE WHEN new_price <> price THEN price ELSE old_price END,
                    image = CASE WHEN new_price <> price THEN COALESCE(new_image, image) ELSE image END,
                    price = new_price, 
                    last_update = (NOW() AT TIME ZONE 'Africa/Cairo')
                WHERE asin = item.asin;
                
                item.old_price := CASE WHEN new_price <> item.price THEN item.price ELSE item.old_price END;
                item.image := CASE WHEN new_price <> item.price THEN COALESCE(new_image, item.image) ELSE item.image END;
                item.price := new_price;
            END IF;

        IF item.price IS NULL OR item.price = 0 THEN CONTINUE; END IF;

        real_tg_token := set.tg_bot_token;
        real_fb_token := set.fb_access_token;
        final_image_url := item.image; 

        SELECT TO_CHAR(NOW() AT TIME ZONE 'Africa/Cairo', 'HH12:MI ') ||
        CASE WHEN TO_CHAR(NOW() AT TIME ZONE 'Africa/Cairo', 'AM') = 'AM' THEN 'ÿµ' ELSE 'ŸÖ' END INTO time_part;

        final_price := FLOOR(item.price * (1 - (COALESCE(item.extra_payment_discount, 0)::float / 100)));
        old_price_val := FLOOR(COALESCE(item.old_price, 0));
        v_clean_title := replace(replace(COALESCE(item.title, ''), '<', '&lt;'), '>', '&gt;');

EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'Update logic failed'; 
END;

IF COALESCE(item.template_id, 0) = 3 AND item.custom_template IS NOT NULL AND trim(item.custom_template) <> '' THEN
price_display := '<b>' || final_price::text || ' ÿ¨</b>';
IF old_price_val > final_price THEN
price_display := price_display || ' (ÿ®ÿØŸÑÿßŸã ŸÖŸÜ <s>' || old_price_val::text || ' ÿ¨</s>)';
END IF;

savings_line := '';
IF COALESCE(item.extra_payment_discount, 0) > 0 THEN
savings_line := '‚ú® ŸàŸÅÿ± ' || item.extra_payment_discount || '% ÿπŸÜÿØ ÿßŸÑÿØŸÅÿπ';
ELSIF COALESCE(item.discount, 0) > 0 THEN
savings_line := 'üî• ÿÆÿµŸÖ ' || item.discount || '%';
END IF;

IF item.footer_text IS NOT NULL AND trim(item.footer_text) <> '' THEN
v_processed_footer := replace(replace(item.footer_text, '((', ''), '))', '');
v_processed_footer := regexp_replace(v_processed_footer, '(https?://[^\s)]+)', '<a href="\1">ÿßÿ∂ÿ∫ÿ∑ ŸáŸÜÿß</a>', 'g');
END IF;

final_text := item.custom_template;
final_text := replace(final_text, '[1]', v_clean_title);
final_text := replace(final_text, '[2]', price_display);
final_text := replace(final_text, '[3]', savings_line);
final_text := replace(final_text, '[4]', trim(item.affiliate_link));
final_text := replace(final_text, '[5]', v_processed_footer);
ELSE

CASE COALESCE(item.template_id, 0)
    WHEN 1 THEN
        final_text := v_clean_title || ' ÿ®ÿ≥ÿπÿ± <b>' || final_price || ' ÿ¨</b>';
        IF old_price_val > final_price THEN 
            final_text := final_text || ' (ÿ®ÿØŸÑÿßŸã ŸÖŸÜ <s>' || old_price_val || ' ÿ¨</s>)'; 
        END IF;
        final_text := final_text || chr(10) || chr(10) || 'ŸÑŸäŸÜŸÉ ÿßŸÑÿπÿ±ÿ∂ : ' || item.affiliate_link;

    WHEN 2 THEN
        final_text := 'üíé ' || v_clean_title || chr(10) || chr(10) || 'üè∑Ô∏è ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ¢ŸÜ: <b>' || final_price || ' ÿ¨ŸÜŸäŸá ŸÅŸÇÿ∑</b>' || chr(10) || chr(10) || 'ŸÑŸäŸÜŸÉ ÿßŸÑÿπÿ±ÿ∂ :' || chr(10) || item.affiliate_link;

    ELSE
        final_text := v_clean_title || chr(10) || chr(10) || 
            '<blockquote>üü¢ ÿßŸÑÿ≥ÿπÿ± ÿßŸÑŸÜŸáÿßÿ¶Ÿä ‚áö <b>' || final_price || ' ÿ¨ŸÜŸäŸá</b>' || 
            CASE WHEN old_price_val > final_price THEN ' (ÿ®ÿØŸÑÿßŸã ŸÖŸÜ <s>' || old_price_val || ' ÿ¨ŸÜŸäŸá</s>)' ELSE '' END ||
            CASE 
                WHEN COALESCE(item.discount, 0) > 0 OR COALESCE(item.extra_payment_discount, 0) > 0 THEN
                    chr(10) || 
                    CASE WHEN COALESCE(item.discount, 0) > 0 THEN 'üî• ÿÆÿµŸÖ ' || item.discount || '%' ELSE '' END ||
                    CASE WHEN COALESCE(item.discount, 0) > 0 AND COALESCE(item.extra_payment_discount, 0) > 0 THEN ' ÿå ' ELSE '' END ||
                    CASE WHEN COALESCE(item.extra_payment_discount, 0) > 0 THEN '‚ú® ŸàŸÅÿ± ' || item.extra_payment_discount || '% ÿπŸÜÿØ ÿßŸÑÿØŸÅÿπ' ELSE '' END
                ELSE '' 
            END || '</blockquote>';
            
        final_text := final_text || chr(10) || chr(10) || 'üîó ŸÑŸäŸÜŸÉ ÿßŸÑŸÖŸÜÿ™ÿ¨:' || chr(10) || item.affiliate_link;
END CASE;
END IF;

final_text := final_text || chr(10) || chr(10);
final_text := regexp_replace(final_text, '\n{3,}', chr(10) || chr(10), 'g');


fb_clean_text := final_text;
fb_clean_text := regexp_replace(fb_clean_text, '<a href="([^"]+)">[^<]*</a>', '\1', 'g');
fb_clean_text := regexp_replace(fb_clean_text, '<[^>]*>', '', 'g');


BEGIN
SELECT content::jsonb INTO tg_result FROM http_post(
('https://api.telegram.org/bot' || real_tg_token || '/sendPhoto')::text,
jsonb_build_object('chat_id', set.tg_chat_id, 'photo', final_image_url, 'caption', final_text, 'parse_mode', 'HTML')::text,
'application/json');
IF tg_result->>'ok' = 'true' THEN v_tg_msg_id := (tg_result->'result'->>'message_id')::int8; END IF;
EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'Telegram Failed'; END;

IF set.fb_page_id IS NOT NULL AND set.fb_page_id <> '' AND real_fb_token IS NOT NULL THEN
BEGIN
SELECT content::jsonb INTO fb_result FROM http_post(
('https://graph.facebook.com/v19.0/' || set.fb_page_id || '/photos')::text,
jsonb_build_object('url', final_image_url, 'message', fb_clean_text, 'access_token', real_fb_token)::text,
'application/json'
);
IF fb_result->>'id' IS NOT NULL THEN 
v_fb_post_id := set.fb_page_id || '_' || (fb_result->>'id'); 
END IF;
EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'Facebook Failed'; END;
END IF;

IF v_tg_msg_id IS NOT NULL OR v_fb_post_id IS NOT NULL THEN
UPDATE products SET 
published_at = (NOW() AT TIME ZONE 'Africa/Cairo')::text,
scheduled_at = NULL,
message_id = COALESCE(v_tg_msg_id, message_id),
fb_post_id = COALESCE(v_fb_post_id, fb_post_id),
last_update = (NOW() AT TIME ZONE 'Africa/Cairo')
WHERE asin = item.asin;
END IF;
END LOOP;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION public.trigger_update_products()
RETURNS void AS $$
BEGIN
 PERFORM net.http_post(
 url := 'https://{{PROJECT_URL}}/functions/v1/update-products',
 headers := '{"Content-Type": "application/json"}'::jsonb,
 body := '{}'::jsonb
 );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.trigger_clean_products()
RETURNS void AS $$
BEGIN
 PERFORM net.http_post(
 url := 'https://{{PROJECT_URL}}/functions/v1/clean-products',
 headers := '{"Content-Type": "application/json"}'::jsonb,
 body := '{}'::jsonb
 );
END;
$$ LANGUAGE plpgsql;




DO $$ 
BEGIN
 PERFORM cron.unschedule(jobname) FROM cron.job WHERE jobname IN ('update-products', 'clean-products', 'auto-post-job');
EXCEPTION WHEN OTHERS THEN 
 RAISE NOTICE 'No jobs to unschedule';
END $$;

SELECT cron.schedule('update-products', '*/10 * * * *', 'SELECT public.trigger_update_products();');
SELECT cron.schedule('clean-products', '0 */6 * * *', 'SELECT public.trigger_clean_products();');
SELECT cron.schedule('auto-post-job', '* * * * *', 'SELECT handle_scheduled_publishing();');



ALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow anon full access settings" ON public.user_settings;
CREATE POLICY "Allow anon full access settings" ON public.user_settings FOR ALL TO anon, authenticated USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Allow anon full access products" ON public.products;
CREATE POLICY "Allow anon full access products" ON public.products FOR ALL TO anon, authenticated USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Allow anon delete products" ON public.products;
CREATE POLICY "Allow anon delete products" ON public.products FOR DELETE TO anon USING (true);

DROP POLICY IF EXISTS "Anon Banners Full Access" ON storage.objects;
CREATE POLICY "Anon Banners Full Access" ON storage.objects 
FOR ALL TO anon 
USING (bucket_id = 'banners') 
WITH CHECK (bucket_id = 'banners');

ALTER FUNCTION handle_scheduled_publishing() SECURITY DEFINER;
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated, service_role;
GRANT USAGE ON SCHEMA public TO postgres;
GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon, authenticated, service_role;

GRANT USAGE ON SCHEMA net TO anon, authenticated, service_role;